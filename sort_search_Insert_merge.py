'''
Given the following definition:
Insertion sort is an iterative algorithm that obtains input data one by one, and gradually produces an ordered output sequence.
In each iteration, the algorithm takes an element from the input sequence and inserts it into the correct position in the ordered sequence.
Iterate in this way until all elements are in order.
The merge sort performs the following iterative operations:
first, the original sequence is regarded as N ordered subsequences containing only 1 element,
and then two adjacent ordered subsequences are merged in each iteration, until only one ordered subsequence left at the end the sequence.
Given the original sequence and the intermediate sequence generated by a sorting algorithm, please judge which sorting algorithm does it applied?

Input format:
Two lines of numbers separated by spaces, corresponding to lists of equal length
The first line represents the unsorted list, and the second line is the intermediate list at a certain step in the sorting algorithm process

Output format:
First output Insertion Sort in line 1 to indicate insertion sort, or Merge Sort to indicate merge sort; then in line 2, output the result sequence of another iteration of the sorting algorithm. The title guarantees that the result of each test is unique. The numbers are separated by spaces, and there must be no extra spaces at the beginning and end of the line

Input sample:
3 1 2 8 7 5 9 4 0 6
1 3 2 8 5 7 4 9 0 6

Sample output:
Merge Sort
1 2 3 8 4 5 7 9 0 6

Input example 2:
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0

Output sample 2:
Insertion Sort
1 2 3 5 7 8 9 4 6 0
'''

# compare 2 sort methods
def which_sort(lst_strt,lst_mid):
    # transfer the input string into list
    lst_strt=list(map(int,lst_strt.split()))
    lst_mid = list(map(int, lst_mid.split()))

    # try merge sort
    input_lst_strt=lst_strt
    input_lst_mid=lst_mid
    try_merge=merge_sort(input_lst_strt, input_lst_mid)

    # if the merge sort return false, try insertion sort
    if try_merge==False:
        insert_sort(lst_strt, lst_mid)


# main function of insert sort
def insert_sort(lst_strt,lst_mid):
    # scan the list from left
    for l in range(1,len(lst_strt)):
        # core insertion operation
        insert_core(lst_strt, l)

        # if the input intermediate list is equal to current one, find the next iteration and stop the operation
        if lst_strt==lst_mid:
            # core insertion operation
            insert_core(lst_strt, l+1)

            # print the result
            print('Insertion Sort')
            print(' '.join(str(l) for l in lst_strt))
            break

    return False


# core insertion operation
def insert_core(lst_strt,l):
    current = lst_strt[l]
    mark = l

    # the element on the left has already been ordered, insert current number into right place
    while mark > 0 and lst_strt[mark] < lst_strt[mark - 1]:
        lst_strt[mark] = lst_strt[mark - 1]
        lst_strt[mark - 1] = current
        mark -= 1
    return lst_strt


# main function of merge sort
def merge_sort(lst_strt, lst_mid):
    # divide the input list into n sub-lists
    lst_strt=[[x]for x in lst_strt]

    # merge adjacent lists into larger list till only 1 list remains, the operation is done
    while len(lst_strt)>1:

        # core function of merge sort
        lst_strt,mid_list=merge_core(lst_strt)

        # if the input intermediate list is equal to current one, find the next iteration and stop the operation
        if mid_list==lst_mid:
            # core function of merge sort
            next_iter=merge_core(lst_strt)

            # print the result
            print ('Merge Sort')
            print(' '.join(str(l) for l in next_iter[1]))
            break

            # if there is need to continue the loop, activate the next sentence
            # lst_strt=next_iter[0]
    return False


# core function of merge sort
def merge_core(lst):
    # create 2 empty lists:
    # one is to save the result with sub-lists for the next iteration
    # another one is used for comparision
    temp_lst,mid_lst = [],[]

    # merge 2 sub-lists into 1 from the input list where the calculated elements should be removed
    while lst:
        # when the input list remains more than one sub-list, conduct the operation to merge 2 lists
        if len(lst) > 1:
            # appending merged list into result list using the core operation for the core merge function
            temp_lst.append(merge_op(lst.pop(0), lst.pop(0)))
            # appending ordered numbers into intermediate list
            for t in temp_lst[-1]:
                mid_lst.append(t)
        # when the input list remains only one sub-list, append it directly to the result list and the intermediate list
        else:
            temp_lst.append(lst.pop(0))
            for t in temp_lst[-1]:
                mid_lst.append(t)
    return temp_lst,mid_lst


# core operation for the core merge function
def merge_op(lst_1,lst_2):
    # create a list to save the result
    res_lst=[]

    # when none of the input lists are empty, pop the smallest value, which is on the left of each ordered list, into the result list
    while lst_1 != [] and lst_2!=[]:
        if lst_1[0]<lst_2[0]:
            res_lst.append(lst_1.pop(0))
        else:
            res_lst.append(lst_2.pop(0))


    # when one input list is empty while another one not, append that one directly to the result list
    if lst_1 ==[]:
        res_lst.extend(lst_2)
    else:
        res_lst.extend(lst_1)
    return res_lst


if __name__ == "__main__":
    lst_strt = '3 1 2 8 7 5 9 4 6 0'#input()
    lst_mid= '1 2 3 5 7 8 9 4 6 0'#input()
    which_sort(lst_strt,lst_mid)

